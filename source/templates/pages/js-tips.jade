extend ../layouts/default

block content
  .section
    .centering
      :markdown

          ## Putting JavaScript on the page

          All JS that you want on the page should be in the dependency tree from the
          browserify bundle entry point, i.e it should be `require()`d by the
          main file, or by some module that is. The bundle should be included
          within a script tag at the end of the `<body>` element.

          There are two common exceptions to this rule:

          1. **jQuery** - We get jQuery from the Google CDN. For this reason it is
            added to the page separately to the browserify bundle. Lots of our browser
            code will rely on jQuery, so it should be included before the bundle.

          2. **Modernizr** - Modernizr must run in the `<head>`. For this reason
            it is added separately to the page and within the `<head>` element.

          **In no circumstances should any JS be added to the page outside the bundle,
          unless there is substantial reason to do so.**

  .section
    .centering
      :markdown

          ## Document Ready

          Lots of jQuery tutorials and examples encouraged large bodies of code
          inside the `$(function () { /* code here */ })` shorthand. This runs the code on
          the document 'ready' event.

          This was useful when JS was typically loaded in the `<head>` of the document.
          Since we load our bundle just before the close of the `<body>`, we are
          guaranteed that any html elements are already loaded in the DOM and are
          'ready'. You should only run code on document ready if you need access to
          HTML that comes after the script that is running. This will be very rare,
          so you should be explicit about it (don't use the shorthand) and comment
          well:

              $(document).on('ready', function () {
                // I'm running on document#ready because…  
              })

  .section
    .centering
      :markdown

          ## Dealing With Global Scope

          When running in a standard browser environment, it was conventional to
          wrap code in a self-executing, annoymous function:

              (function () {
                
                // Anything assigned here will not be in global scope

              }())

          This pattern is completely unnecessary with our setup, as browserify wraps each
          module in its own scope. You shoud **not** use it.

          If, on the other hand, you *want* something to be global, you should explicitely
          add it to a global object like `window`:

              window.smiley = ':)'

  .section
    .centering
      :markdown

        ## Use Buttons
        
        Use of the `<button>` element is preferable in places. We generally use these
        in place of links when there is no fallback href attribute – usually when
        triggering JS functionality with no required level of fallback. Using an `<a>`
        is inconvenient and inappropriate, as we need to give it an irrelevant href
        and prevent the bubbling of the click event, only to achieve the functionality of
        a button.

  .section
    .centering
      :markdown

          ## File Structure

          The main frontend JS directory should contain the top level directories:

          * **app** – this is where our main body of code will go. The web server should *not* be asked for anything in this directory.
          * **build** – this is where our output bundles will go. The web server *should* be asked for things in this directory. Do not modify anything in this directory, or check it in to source control. It is generated by running the build script, and all code that ends up here comes from somewhere else. Any changes will be overwritten by the build.
          * **lib** and **lib/vendor** – this is where any code needs to be run outside of the bundle should live, eg. analytics code, Modernizr, and local jQuery fallback.

          Within **app**, the following conventions have emerged:

          * **index.js** – the entry point to the application. This should set up anything that is required globally.
          * **widgets/** – this directory should contain modules that create functionality for widgets on the site.
          * **widgets.js** – should `require()` all of the widgets, and conditionally instantiate them, should they be required on the page.
          * **lib/** - anything that can or will be used more that once, but is not available in npm.
          * **lib/vendor** - any code that should live in **lib** that is *not* authored by us.

          See [Catfish Blank](https://github.com/clocklimited/CatfishBlank/blob/develop/site/public/js) (private repo) for an example of this structure in use.


  .section
    .centering
      :markdown

          ## Avoiding jQuery-itis

          The jQuery plugin interface is a nice abstraction for many frontend situations. However, it
          is overused, and not always a good fit. Always think about how best to abstract the feature
          or problem you are writing code for. If *everything* is a plugin, you end up programming via
          massive option hashes, rather than instances with methods and properties.

          It is better to write the correct abstraction, then wire it up to the jQuery plugin interface
          later, to fit that simplistic use case if required.

          For example:

              // Write a constructor for hero objects that has methods etc.
              function Hero($el, options) {}
              Hero.prototype.start = function () {}
              Hero.prototype.stop = function () {}
              Hero.prototype.on = function (event, callback) {}
              Hero.prototype.off = function (arg) {}

              // Export the hero constructor for non plugin-y use
              module.exports = Hero

              // Create a jquery plugin out of the constructor
              $.fn.hero = function (options) {
                return this.each(function () {
                  var hero = new Hero($this, options)
                  hero.start()
                })
              }

              // Using the non plugin-y version looks like this
              var $hero = $('.js-hero')
                , myHero = new Hero($hero, {})
              $hero.on('click', function () {
                myHero.stop()
              })
              myHero.on('change', doSomethingOnChange)
              myHero.start()

              // Using the non plugin version looks like this
              $('.js-hero').hero()

              // You can't interface with any of the instance methods
              // like start(), stop() or on() here because the jQuery
              // plugin has returned the collection of elements that was
              // passed to it. If you want to keep state, then a back
              // reference to the element must be stored on the element.
              // This makes it a poor abstraction, so
              // use the first example.

  .section
    .centering
      :markdown

          ## Templating

          **Never** write HTML in JS strings. It is error prone and untidy. With our browserify
          build we can store jade templates in their own files, and bring them in pre-compiled
          with the [browjadify](http://npm.im/browjadify) transform at build time.

          That means our JS can bring in templates like so:

              var compileJade = require('browjadify')
                , template = compileJade(__dirname + '/person.jade')

              var myHtml = template({ /* template data */ })

  .section
    .centering
      :markdown

          ## Dollar ($) Convention

          If a variable references a jQuery object/collection, begin its name with
          a dollar to signify so. This helps the reader to understand the program.
          
          To preserve the integrity of this convention, don't begin a variable name
          with a dollar if it doesn't reference a jQuery object.

              // Bad
              var spans = $('span')
              var $coins = [ 1, 2, 5, 10, 20, 50, 100, 200 ]

              // Good
              var $spans = $('span')
              var coins = [ 1, 2, 5, 10, 20, 50, 100, 200 ]


  .section
    .centering
      :markdown

          ## Naming Handler Functions

          If you name event handler functions, it's easier to clean up after yourself
          when unbinding the handlers.

              $('a').on('click', function () {
                console.log('anchor clicked!')
              })

              // How to unbind this event?

              // 1. .off()?

              $('a').off('click')

              // This will remove *all* click event handlers. There could be
              // some really important event listener listening to clicks
              // that your program doesn't know about. That means it'd be
              // irresponsible to remove all handlers.

              // 2. Event namespace?

              $('a').on('click.mynamespace', function () {
                console.log('anchor clicked!')
              })

              $('a').off('click.namespace')

              // This removes all event handlers with the given namespace.
              // This is much more responsible, although there is a chance
              // that someone else could have used the same namespace.

              // 3. Named functions

              function logClick() {
                console.log('anchor clicked!')
              }

              $('a').on('click', logClick)

              $('a').off('click', logClick)

              // This explicitely removes the function that we bound ourselves